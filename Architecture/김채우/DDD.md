# Domain Driven Development

---

# 1. 핵심 개념
## 1.1. Domain
소프트웨어가 해결하려는 비즈니스 영역이나 문제 공간
## 1.2. 유비쿼터스 언어
도메인 전문가와 개발자가 공통으로 사용하는 언어
코드, 문서, 대화 등 모든 의사소통에서 일관되게 사용
## 1.3. Bounded Context
도메인을 여러 개의 독립된 컨텍스트로 분리해 복잡성을 관리하는 큰 경계
어떤 도메인 모델이 통하는 경계를 정해 같은 용어나 규칙이 그 경계 안에서만 일관된 의미를 갖게 만드는 개념
한 바운디드 컨텍스트는 논리적으로 하나의 모델을 가짐
용어 기준으로 컨텍스트를 나눠 같은 단어라도 컨텍스트가 다르면 다른 의미를 허용
### 1.3.1. 경계를 나누는 방법
도메인(비즈니스 분야)과 컨텍스트(도메인 안의 특정 문제 영역)를 구분하고 문제 영역마다 용어/개념/규칙이 일관되게 적용되도록 경계를 잡음
ex. 상품이라는 단어도 카탈로그/재고/주문 등 하위 영역에 따라 의미와 필요한 속성이 달라질 수 있음
- 이를 한 모델로 통합하려 한다면 모델이 어중간해짐
이상: 하위 도메인과 바운디드 컨텍스트가 1:1
현실: 1:1이 아닐 수도 있음
## 1.4. Aggregate
도메인 모델 내에서 일관성을 유지해야 하는 객체들의 집합
하나의 트랜잭션 안에서 처리되는 작은 단위
도메인 모델 내부에서 일관성을 같이 지켜야 하는 객체 묶음을 한 트랜잭션 단위로 다루기 위한 경계
한 트랜잭션 안에서 처리되는 작은 단위
이 단위를 기준으로 불변조건을 지키도록 설계하는 것이 핵심
## 1.5. Bounded Context와 Aggregate의 관계
Bounded Context가 모델이 섞이지 않게 하는 큰 경계라면,
애그리거트는 그 Context 내부에서 트랜잭션/일관성 경계를 정하는 더 작은 경계
주문 컨텍스트 안에 Order 애그리거트를 두고 결제/배송은 같은 컨텍스트라도 별도의 애그리게트로 두어 트랜잭션을 쪼갬

---
# 2. 도메인 서비스 vs 응용 서비스
DDD에서는 서비스의 역할을 명확히 구분
| 구분         | 도메인 서비스         | 응용 서비스             |
| ---------- | --------------- | ------------------ |
| 위치         | domain 계층       | application 계층     |
| 역할         | 비즈니스 로직 처리      | 애플리케이션 흐름 관리       |
| 책임         | 도메인 상태 변경 및 계산  | 도메인 객체와 외부 시스템 조율  |
| 비즈니스 로직 포함 | O               | X                  |
| 예시         | 결제 금액 계산, 계좌 이체 | 트랜잭션 관리, 사용자 요청 처리 |

---
# 3. 주요 이점
## 3.1. 비즈니스 요구사항의 정확한 반영
도메인 모델을 중심으로 설계해 비즈니스 로직을 정확히 구현
## 3.2. 협업의 효율성 향상
공통된 도메인 모델과 유비쿼터스 언어를 통해 팀 내 소통 원활
새로운 개발자가 쉽게 요구사항을 파악 가능
## 3.3. 높은 응집력과 낮은 결합도
각 도메인을 독립적으로 설계해 유지보수성과 확장성 향상
## 3.4. 복잡성 관리
바운디드 컨텍스트와 애그리거트를 통해 도메인의 복잡성 효과적으로 관리 가능